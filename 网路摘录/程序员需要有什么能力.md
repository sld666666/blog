# 程序员需要有什么能力

一本书：Designing Data-Intensive Applications， 对应程序员3能力中的工具箱深度广度两个概念-1：多范式编程和最小表达力原则(least expressiveness principle), 对应程序员3能力中的程序语言理解深度和表达抽象能力两个概念-2：领域驱动设计(Domain Driven Design)，对应程序员3能力中的方法论，编程大道(programming in the big)，和构架能力

关于程序员3能力：（引自自己的一个答案：阿莱克西斯：作为一名程序员，我这属于什么水平？）1. 工具箱广度深度，或者说在技术选型上控制系统复杂度的能力，广度：懂多少数据库/数据处理框架/AWS几个重要的Service了解多少/著名的开源软件框架工具了解程度, （这个一年前的答案列了一些我们当时经常用的，业界也很流行的，您可以参考下。阿莱克西斯：后端所谓复杂的问题是什么？ ） 广度决定了眼界； 深度：为什么数据库要这么实现设计，为什么AWS这个地方有这个缺陷（比如SQS为什么是可乱序的queue），看似类似的几个框架，在本质上有什么不同，是在哪个本质问题上做了哪些决定行的trade-off导致了它们在设计实现和提供的功能上分道扬镳？ 深度决定了能否真的在合适的场景应用合适的能力与工具。2. 程序语言理解深度和表达抽象能力，这是在实现上控制复杂度的能力，懂不懂得最小表达力原则？懂得几种编程范式？它们之间怎么根据具体情况作出取舍？是否知道怎样才能把code写成诗？怎么样才能在重重困难中，坚守高聚合，低耦合？怎样组织程序，才能使得让程序正向流动产生期待效果之外，程序能否根据效果／结果，倒推并很容易的倒推出这样的一种结果是由什么原因，那个组件造成的(这是系统怎么才能很容易进化的关键，也是“做出来就是好的”程序员最难克服的一点)？code写出来逻辑线是否清晰可见？阿莱克西斯：编程到底难在哪里？  (3. 方法论，编程大道(programming in the big)，和构架能力，这是在时间跨度的整体上控制复杂度的能力，辨别什么是对的，应该做什么的能力；在时间跨度上，在信息不完整的情况下，现在怎么构架，才能使得当将来信息完整了，我们能很轻松的根据将来的正确信息，把系统调整成最好最正确的状态，什么决定应该现在做，什么决定可以和怎么样才能留给将来做，并且在这个过程中，保证能够支持业务正常运转。在整体上，怎么把需求获取/设计/coding/测试/安全/部署/运行监测/报警/性能/系统回馈分析/数据统计/报表…等等在全局把握，安排的妥妥当当相互支持而不是相互抵触，相互使绊子。这里包含的知识包括，到底是waterfall， TDD，BDD，还是type driven，怎么执行Agile，什么是devOps，continuous delivery。 到底应该是技术决定业务，还是业务决定技术？。给一个100人的团队和超复杂／抽象的需求（比如需求就是让公司业务翻一倍，怎么翻一倍这个抽象问题要怎么分解成n个大问题，这n个大问题怎么分解成m个中问题。。。。），怎么把抽象问题落到实处，怎么能把大的问题分解成哪怕是比较弱的程序员也可以解决的小问题，然后还要证明这是根据现在的信息，可以做出的最好的决定。2017年，你看了啥很好的计算机的博客/书/视频？  这个回答中关于DDD和Clean Architecture的介绍讨论了一些这方面的问题您可以看下

## 这些能力看什么书

为什么是这本书， 这两个概念，是什么质变：关于一书：Designing Data-Intensive Applications： 由于我的主要工作是利用云技术，做后端的大数据模型，或者高性能，高弹性，高可用性的service，所以数据处理，和云技术是我工具箱里最重要的一部分工具。我之前比较深入的（内部怎么工作的深度，每个系统至少读过一本书，有一些看过源代码）学过Oracle, HBase, Cassandra, Redshift, Hadoop, Spark Kafka, Storm, Zookeeper...Amazon自己的DynamoDB, Kinesis, SQS／SNS, AWS Lambda, Step Function, SimpleWorkflow, EMR... 但是我的学习是像没头苍蝇一样的，是盲目的，哪个技术火，就学哪个，总觉得这些东西之间模模糊糊的是有联系的，感觉是有一些东西是可以总结起来的。。。脑子里或者说工具箱里里的东西很多，但是却非常乱，概念实现经常记混，我经常在想：如果能总结归类，用更科学的方法去记住所有我学过的技术，那就好了。。。然后我就遇到了这本书，我读了三遍，然后感觉一切都理顺了… 如果我先读了这本书，才去学上边这些东西，那么我花费的时间将是原来的3分之一到5分之一左右。这本书在广度和一定程度的深度（如果对进一步深度有要求，可以读完此书的reference）上，概括和总结了数据系统，分布式或非分布式环境下面临的本质问题，和解决方案的分类，看完这本，我开始理解了“为什么”这么多的分布式系统要这么设计。而这本书上千的引用论文，给我指明了一条系统学习理论的明路。关于多范式编程和最小表达力原则(least expressiveness principle)：学了好多语言，设计模式，AOP，范型，反射，DCI。。。不知什么时候起，我已经忘记了我为什么要学习他们了，我的程序开始变成一个程序员的行为艺术，简直可谓花式编程。怎么样能用别人都不懂的花式技术秀翻全组，变成了我觉得可以体现我的学识的关键。。。（在这里要跟接手和维护我花式行为艺术的同学深深的道歉。。。）直到我了解到了多范式编程(Multi-Paradigm Programming)和最小表达力原则(least expressiveness principle), 我才中混沌中惊醒，回归初心，简化程序，用尽可能简单的程序来解决尽可能复杂的问题，才是我们发明和学习了这么多技术的最终目的啊！关于领域驱动设计(Domain Driven Design)：从具体的大处来说，它让我明白了“为什么要有程序员”，这个话题很大很抽象，下边的引用有一些详述。 从小的来说，它让我懂得了怎么样用系统的方法来设计系统，实现系统，从而让VP，Director，各级开发经理, 产品经理，客户，和我们组配合的机器学习科学家，统计学家，经济学家，他们脑子里的系统，和我们程序员的code的组织，系统的组件设计实现，能够有一个清晰的对应，且这个清晰的对应，如何在无数的需求改变，无数的技术升级中，在长期的时间跨度上，如何能够坚守住，如何持续保证概念模型(concept model)和实现模型(implementation model)的一致，并且是清晰一致。那么，一个小的脑子里的模型改动，必然只会引起一个系统的小的改动。做到这点，是在长远的时间角度，在考虑了未知的未来，考虑了明天的你，团队，客户，都会收到新的未知的信息的情况下(而不是根据一个时间点的需求)保持一个健康，可业务拓展，有竞争力的，能够成为组部门公司之脊梁的系统的关键！用比喻义来说：如果说Designing Data-Intensive Applications是逍遥子百年功力，是莽牯朱蛤，是张无忌吃的昆仑山蟠桃，给你无穷的内力，那么这些方法论则是北冥神功，九阳神功，易筋经，教你如何驾驭这力量，而不是自爆而亡。
