1. HashMap，Hashtable，ConcurrentHashMap差异，使用场景 => 不了解ConcurrentHashMap
2. JVM内存模型 => 讲得不太清楚
3. 数据库的乐观锁和悲观锁 => 对数据库不熟悉，不知道
4. UML类图中元素关系 => 不熟悉
5. 看什么书 

候选人不足：Java基础一般，集合和多线程基础问题能回答出来，但是稍微深入一点就不了解。比如
（1）了解线程安全的集合有哪些，但认为线程安全的在多线程环境下多条件综合使用线程安全的集合就一定是线程安全的
（2）了解ConcurrentHashMap线程安全的原理，并且自己介绍看过源代码。但问该同学 size() 方法是否有做线程安全控制，该同学回到只看了 put 操作的源代码。。。这太尴尬了。让该同学自己思考下size()是否需要加同步锁控制。该同学认为在size方法上要加锁。判断有误



finalize 约等于析构函数

悲观锁： 只有一个现实失败或者成功以后下一个才能进行.悲观并发控制实际上是“先取锁再访问”的保守策略，为数据处理的安全提供了保证。但是在效率方面，处理加锁的机制会让数据库产生额外的开销，还有增加产生死锁的机会；另外，在只读型事务处理中由于不会产生冲突，也没必要使用锁，这样做只能增加系统负载；还有会降低了并行性，一个事务如果锁定了某行数据，其他事务就必须等待该事务处理完才可以处理那行数
乐观锁:它假设多用户并发的事务在处理时不会彼此互相影响，各事务能够在不产生锁的情况下处理各自影响的那部分数据。在提交数据更新之前，每个事务会先检查在该事务读取数据后，有没有其他事务又修改了该数据。如果其他事务有更新的话，正在提交的事务会进行回滚。